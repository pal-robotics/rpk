#! /usr/bin/python3

import json
import time
from rclpy.node import Node

from hri_actions_msgs.msg import Intent


class ApplicationController(Node):

    def __init__(self) -> None:
        super().__init__('app_{{ id }}')

        self.get_logger().info("Initialising...")

        self._intents_sub = self.create_subscription(
            Intent, 
            '/intents', 
            self.on_intent, 
            10)
        self.get_logger().info("Listening to %s topic" % 
            self._intents_sub.topic_name)

        # Define a timer that fires every second to call the run function
        timer_period = 1  # in sec
        self.timer = self.create_timer(timer_period, self.run)
        # Cancel timer until applicationController is requested to start
        self.timer.cancel()  

        #######################################
        #
        # TODO: Add here any initialization steps
        # that should occur only once.
        #
        self.inc = 0

    def on_intent(self, msg):

        self.get_logger().info("Received an intent: %s" % msg.intent)

        #######################################
        #
        # TODO: Define here how your application
        # should react when receiving an user
        # intent.

        data = json.loads(msg.data) if msg.data else {}
        source = msg.source
        modality = msg.modality
        confidence = msg.confidence
        priority_hint = msg.priority

        #######################################
        #
        # If you do not need to process specific
        # intents, simply remove the corresponding
        # line(s).
        #

{% if intents %}
{% for intent in intents %}
        # Intent {{ intent.intent }}: {{ intent.description }}
        {{ "if" if loop.index == 1 else "elif"}} msg.intent == Intent.{{ intent.intent }}:
{% if intent.required_thematic_roles %}
            # the 'data' dictionary should contain at least the following keys:
{% for role in intent.required_thematic_roles %}
            # - {{ role }}
{% endfor %}
{% endif %}
{% if intent.intent == "ENGAGE_WITH" and robot == "ARI" %}

            # As an example, we call here the TTS and play_motion action server
            # to implement a very simple behaviour when someone engages with 
            # the robot.
            from rclpy.action import ActionClient

            from pal_tts_msgs.action import TTS
            from play_motion2_msgs.action import PlayMotion2

            tts = ActionClient(self, TTS, 'tts')
            play_motion = ActionClient(self, PlayMotion2, 'play_motion2')

            tts_goal = TTS.Goal()
            tts_goal.sentence = "Hello, I'm ARI. Nice to meet you!"
            tts_goal.lang_id = "en_GB"
            tts.wait_for_server()
            # tts.send_goal_and_wait(tts_goal) --> ROS2: similar wait option?
            tts.send_goal_async(tts_goal)

            motion_goal = PlayMotion2.Goal(motion_name="bow")
            play_motion.wait_for_server()
            # play_motion.send_goal_and_wait(motion_goal) --> ROS2: similar wait option?
            play_motion.send_goal(motion_goal)
{% elif intent.intent == "PRESENT_CONTENT" %}

            # handle intents to present specific content by simply
            # loading the corresponding page onto the touchscreen
            from pal_web_msgs.msg import WebGoTo

            web_goto_pub = self.create_publisher(
                WebGoTo, '/web/go_to', queue_size=1)

            self.get_logger().info(
                "Displaying page %s on the touchscreen..." % data["object"])
            msg = WebGoTo()
            msg.type = WebGoTo.TOUCH_PAGE
            msg.value = data["object"]
            web_goto_pub.publish(msg)
{% else %}
            pass
{% endif %}

{% endfor %}
        # custom intent?
        else:
            self.get_logger().warning("I don't know how to process intent " 
                                      "<%s>!" % msg.intent)
{% else %}
        # handle here the different intents
        if msg.intent == "your_intent": # or one of the Intent.msg constants
            pass

        # elif...

        else:
            self.get_logger().warning("I don't know how to process intent "
                                      "<%s>!" % msg.intent)
{% endif %}

    def stop(self) -> None:
        """Stop the timer to stop the application"""

        self.timer.cancel()
        self.get_logger().info("Stopping application")

    def start(self) -> None:
        """Reset the timer to re-start the application"""

        self.timer.reset()
        self.get_logger().info("Running")

    def run(self) -> None:
        """
        The main task of your application. Implements the background processing 
        of your applcation.

        This function will be triggered by the timer in the class, and only
        when the timer is active.
        """

        #######################################
        #
        # TODO: Implement here any background 
        # task required by your application 
        # If application has been stopped,
        # this function will not be called
        #

        self.get_logger().info(str(self.inc))
        self.inc += 1

