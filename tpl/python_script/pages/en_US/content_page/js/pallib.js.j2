import * as RRLIB from './rrlib.js'

class PalLib {
	constructor() {
		this.ros = new RRLIB.Ros({
			host: 'http://' + window.location.hostname
		});
		this.motion_goal_tracker = -1;
		this.tts_goal_tracker = -1;
	}

	init() {
		this.motion_manager_client = new RRLIB.ActionClient({
			ros: this.ros,
			name: "motion_manager"
		});
		this.tts_client = new RRLIB.ActionClient({
			ros: this.ros,
			name: "tts"
		});
		this.input_pub = new RRLIB.Topic({
			ros: this.ros,
			name: "user_input"
		});
	}

	// Execute an existing named motion
	executeMotion(motion, cb) {
		this.motion_manager_client.sendGoal({
			filename: motion,
			plan: true,
			checkSafety: true,
			repeat: false,
			priority: 50,
			queueTimeout: 0
		}, (response) => {
			cb(response.goal_id);
		});
	}
	// Execute a named motion and execute a callback after it is finished
	executeAndTrackMotion(motion, tracking_interval, end_cb, goal_cb) {
		let goal_id = "";
		// Launch the motion
		this.executeMotion(motion, (id) => {
			goal_id = id;
			if (goal_cb !== undefined)
				goal_cb(id);
		});
		// Start the motion tracker
		this.motion_goal_tracker = window.setInterval(() => {
			if (goal_id != "")
				this.motion_manager_client.findGoalState(goal_id, (state) => {
					if (state != "NOT FOUND" && state != "ACTIVE") {
						end_cb(state);
						window.clearInterval(this.motion_goal_tracker);
						this.motion_goal_tracker = -1
					}
				});
		}, 1000);
	}
	// Say a specific text in a given language
	say(text, lang, cb) {
		this.tts_client.sendGoal({
			rawtext: {
				text: text,
				lang_id: lang
			}
		}, (response) => {
			cb(response.goal_id);
		});
	}
	// Say a sentence in a language, and execute a callback when it is finished
	sayAndTrack(text, lang, tracking_interval, end_cb, goal_cb) {
		let goal_id = "";
		// Launch the motion
		this.say(text, lang, (id) => {
			goal_id = id;
			if (goal_cb !== undefined)
				goal_cb(id);
		});
		// Start the motion tracker
		this.tts_goal_tracker = window.setInterval(() => {
			if (goal_id != "")
				this.tts_client.findGoalState(goal_id, (state) => {
					if (state != "NOT FOUND" && state != "ACTIVE") {
						end_cb(state);
						window.clearInterval(this.tts_goal_tracker);
						this.tts_goal_tracker = -1
					}
				});
		}, tracking_interval);
	}
	// Say a specific text stored on the robot
	sayPregen(section, key, lang, cb) {
		this.tts_client.sendGoal({
			text: {
				section: section,
				key: key,
				lang_id: lang
			}
		}, (response) => {
			cb(response.goal_id);
		});
	}
	// Say a specific text stored on the robot, and execute a callback when it is finished
	sayPregenAndTrack(section, key, lang, goal_cb, tracking_interval, end_cb) {
		let goal_id = "";
		// Launch the motion
		this.sayPregen(section, key, lang, (id) => {
			goal_id = id;
			if (goal_cb !== undefined)
				goal_cb(id);
		});
		// Start the motion tracker
		this.tts_goal_tracker = window.setInterval(() => {
			if (goal_id != "")
				this.tts_client.findGoalState(goal_id, (state) => {
					if (state != "NOT FOUND" && state != "ACTIVE") {
						end_cb(state);
						window.clearInterval(this.tts_goal_tracker);
						this.tts_goal_tracker = -1
					}
				});
		}, tracking_interval);
	}
	// Send an input message, with an optional array of key/value pairs in the form of
	// args: [{key: 'key1',value: 'val1'}]
	sendInput(input_action, args) {
		if (args === undefined)
			args = [];

		this.input_pub.publish({
			action: input_action,
			args: args
		});
	}
	// Send an Input accept
	sendAccept() {
		this.sendInput("INPUT_ACCEPT", []);
	}
	// Send an Input reject
	sendReject() {
		this.sendInput("INPUT_REJECT", []);
	}
	// Send an Input cancel
	sendCancel() {
		this.sendInput("INPUT_CANCEL", []);
	}
}

export default PalLib