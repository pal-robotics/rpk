{{ name }}
====================

Welcome to your new robot application!

What are the next steps?

## Customize your application

By default, the template does not do anything useful. However, it demonstrates how to use *intents* to trigger behaviours or react to events.

*Intents* are usually generated by your robot's users. It can happen:
- through automatic perception (eg, someone approaches and seems to interact),
- through verbal interaction (eg, someone tells the robot to go somewhere)
- through interactions with the touchscreen (eg, someone presses a button to trigger a behaviour).

Your application template already contains examples of each of these possible interactions.

## Install on the robot

To install you app on the robot, you need to follow the following steps:

1. `pal_deploy` your code to the robot
2. install the webpages (if you are using any)

### Deploy the application controller to the robot

**To deploy the code to the robot, you *must* be running the following commands form within your Developer SDK Docker image!**

- from inside your Developer SDK Docker image, go to root of the project
- run `ros2 run pal_deploy deploy.py --package {{ id }} {{ robot | lower }}-XXc` (replace `{{ robot | lower }}-XXc` by your actual robot)

You can now `ssh` onto the robot (`ssh pal@{{ robot | lower }}-XXc`, password `pal`), and go to your project: `cd ~/deployed_ws/share/{{ id }}`

{% if (robot == "ari") %}

### Install the webpages

To install your webpages onto the robot, check `pages_only_ari/README.md`.

{% endif %}

## Run your application

`ssh` onto the robot (`ssh pal@{{ robot | lower }}-XXc`, password `pal`).

There are several ways to run the application:

1. Manually run your application:

`ros2 run {{ id }} run_app`

Since your application controller is a lifecycle node, you need to manage it through the 
lifecycle tools. You can execute the following to transit the mission controller as follows:

``ros2 lifecycle set /app_{{ id }} configure``
``ros2 lifecycle set /app_{{ id }} activate``

To stop it (but not reseting it's internal variables):
``ros2 lifecycle set /app_{{ id }} activate``

To stop it and clean it:
``ros2 lifecycle set /app_{{ id }} deactivate``
``ros2 lifecycle set /app_{{ id }} cleanup``

2. Automatically launch the app and transition to an active state:

`ros2 launch {{ id }} {{ id }}.launch.py`

3. Run at startup:

To make your application run at startup, uncomment the related lines in `setup.py` and reinstall the package. 
You can then start, stop or view the logs of the application as a module. See [Application management](https://docs.pal-robotics.com/sdk-dev/management/application-management) 
for more details. 

Find more details at the [PAL Developer Center](https://docs.pal-robotics.com/{{ robot | lower }})

### Testing

You can test the application from the terminal by sending some intents:

``ros2 topic pub /intents hri_actions_msgs/msg/Intent "{intent: '__intent_perform_motion__', data: '{\"object\": \"inspect_surroundings\"}', source: '__myself__', modality: '__modality_motion__', priority: 128, confidence: 1.0}"``

``ros2 topic pub /intents hri_actions_msgs/msg/Intent "{intent: '__intent_say__', data: '{\"object\": \"hello how are you?\"}', source: '__myself__', modality: '__modality_speech__', priority: 128, confidence: 1.0}"``

``ros2 topic pub /inte': ros2 topic pub /intents hri_actions_msgs/msg/Intent "{intent: '__intent_engage_with__'}" ``

